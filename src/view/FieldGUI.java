package view;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.JPanel;

/**
 * Graphic user interface of the game's main view
 *
 * @author Ignacio Slater Mu√±oz
 * @version 3.0b3
 * @since 3.0
 */
public class FieldGUI extends JPanel {

  /** Each cell is a 128x128 square */
  private final int DIMENSIONS = 128;
  private final int LEFT_COLLISION = 1;
  private final int RIGHT_COLLISION = 2;
  private final int TOP_COLLISION = 3;
  private final int BOTTOM_COLLISION = 4;

  private ArrayList<Wall> walls;
  private ArrayList<Baggage> baggs;
  private ArrayList<Area> areas;

  private Player soko;
  private int fieldWidth = 0;
  private int fieldHeigth = 0;

  private boolean isCompleted = false;

  /**
   * Creates the view for the game field.
   */
  public FieldGUI() {
    addKeyListener(new TAdapter());
    setFocusable(true);
    initField();
  }

  /**
   * Initializes the field
   */
  private void initField() {
    walls = new ArrayList<>();
    baggs = new ArrayList<>();
    areas = new ArrayList<>();

    final int OFFSET = 30;
    int x = OFFSET;
    int y = OFFSET;

    Wall wall;
    Baggage b;
    Area a;

    final String level = "    ######\n"
        + "    ##   #\n"
        + "    ##$  #\n"
        + "  ####  $##\n"
        + "  ##  $ $ #\n"
        + "#### # ## #   ######\n"
        + "##   # ## #####  ..#\n"
        + "## $  $          ..#\n"
        + "###### ### #@##  ..#\n"
        + "    ##     #########\n"
        + "    ########\n";

    for (int i = 0; i < level.length(); i++) {
      char item = level.charAt(i);
      switch (item) {
        case '\n':
          y += DIMENSIONS;
          if (this.fieldWidth < x) {
            this.fieldWidth = x;
          }
          x = OFFSET;
          break;
        case '#':
          wall = new Wall(x, y);
          walls.add(wall);
          x += DIMENSIONS;
          break;
        case '$':
          b = new Baggage(x, y);
          baggs.add(b);
          x += DIMENSIONS;
          break;
        case '.':
          a = new Area(x, y);
          areas.add(a);
          x += DIMENSIONS;
          break;
        case '@':
          soko = new Player(x, y);
          x += DIMENSIONS;
          break;
        case ' ':
          x += DIMENSIONS;
          break;
        default:
          break;
      }
      fieldHeigth = y;
    }
  }

  /**
   * @return the field's width (in pixels)
   */
  public int getFieldWidth() {
    return this.fieldWidth;
  }

  /**
   * @return the field's height (in pixels)
   */
  public int getFieldHeight() {
    return this.fieldHeigth;
  }

  @Override
  public void paintComponent(Graphics graphics) {
    super.paintComponent(graphics);
    buildField(graphics);
  }

  /**
   * Builds the field according to the map generated by the controller
   *
   * @param graphics
   *     the object that's going to be displayed
   */
  private void buildField(Graphics graphics) {
    graphics.setColor(new Color(250, 240, 170));
    graphics.fillRect(0, 0, this.getWidth(), this.getHeight());

    ArrayList<Actor> field = new ArrayList<>();

    field.addAll(walls);
    field.addAll(areas);
    field.addAll(baggs);
    field.add(soko);

    for (Actor item : field) {
      if (item instanceof Player || item instanceof Baggage) {
        graphics.drawImage(item.getImage(), item.x() + 2, item.y() + 2, this);
      } else {
        graphics.drawImage(item.getImage(), item.x(), item.y(), this);
      }
      if (isCompleted) {
        graphics.setColor(new Color(0, 0, 0));
        graphics.drawString("Completed", 25, 20);
      }
    }
  }

  private boolean checkBagCollision(int type) {
    switch (type) {
      case LEFT_COLLISION:
        for (int i = 0; i < baggs.size(); i++) {
          Baggage bag = baggs.get(i);
          if (soko.isLeftCollision(bag)) {
            for (Baggage item : baggs) {
              if (!bag.equals(item)) {
                if (bag.isLeftCollision(item)) {
                  return true;
                }
              }
              if (checkWallCollision(bag, LEFT_COLLISION)) {
                return true;
              }
            }
            bag.move(-DIMENSIONS, 0);
            isCompleted();
          }
        }
        return false;
      case RIGHT_COLLISION:
        for (int i = 0; i < baggs.size(); i++) {
          Baggage bag = baggs.get(i);
          if (soko.isRightCollision(bag)) {
            for (Baggage item : baggs) {
              if (!bag.equals(item)) {
                if (bag.isRightCollision(item)) {
                  return true;
                }
              }
              if (checkWallCollision(bag, RIGHT_COLLISION)) {
                return true;
              }
            }
            bag.move(DIMENSIONS, 0);
            isCompleted();
          }
        }
        return false;
      case TOP_COLLISION:
        for (int i = 0; i < baggs.size(); i++) {
          Baggage bag = baggs.get(i);
          if (soko.isTopCollision(bag)) {
            for (Baggage item : baggs) {
              if (!bag.equals(item)) {
                if (bag.isTopCollision(item)) {
                  return true;
                }
              }
              if (checkWallCollision(bag, TOP_COLLISION)) {
                return true;
              }
            }
            bag.move(0, -DIMENSIONS);
            isCompleted();
          }
        }
        return false;
      case BOTTOM_COLLISION:
        for (int i = 0; i < baggs.size(); i++) {
          Baggage bag = baggs.get(i);
          if (soko.isBottomCollision(bag)) {
            for (Baggage item : baggs) {
              if (!bag.equals(item)) {
                if (bag.isBottomCollision(item)) {
                  return true;
                }
              }
              if (checkWallCollision(bag, BOTTOM_COLLISION)) {
                return true;
              }
            }
            bag.move(0, DIMENSIONS);
            isCompleted();
          }
        }
        break;
      default:
        break;
    }
    return false;
  }

  private boolean checkWallCollision(Actor actor, int type) {
    switch (type) {
      case LEFT_COLLISION:
        for (Wall wall : walls) {
          if (actor.isLeftCollision(wall)) {
            return true;
          }
        }
        return false;
      case RIGHT_COLLISION:
        for (Wall wall : walls) {
          if (actor.isRightCollision(wall)) {
            return true;
          }
        }
        return false;
      case TOP_COLLISION:
        for (Wall wall : walls) {
          if (actor.isTopCollision(wall)) {
            return true;
          }
        }
        return false;
      case BOTTOM_COLLISION:
        for (Wall wall : walls) {
          if (actor.isBottomCollision(wall)) {
            return true;
          }
        }
        return false;
      default:
        break;
    }
    return false;
  }

  public void isCompleted() {
    int nOfBags = baggs.size();
    int finishedBags = 0;

    for (Baggage bag : baggs) {
      for (int j = 0; j < nOfBags; j++) {
        Area area = areas.get(j);
        if (bag.x() == area.x() && bag.y() == area.y()) {
          finishedBags += 1;
        }
      }
    }
    if (finishedBags == nOfBags) {
      isCompleted = true;
      repaint();
    }
  }

  public void restartLevel() {
    areas.clear();
    baggs.clear();
    walls.clear();

    initField();

    if (isCompleted) {
      isCompleted = false;
    }
  }

  private class TAdapter extends KeyAdapter {

    @Override
    public void keyPressed(KeyEvent e) {
      if (isCompleted) {
        return;
      }
      int key = e.getKeyCode();
      switch (key) {
        case KeyEvent.VK_LEFT:
          if (checkWallCollision(soko,
              LEFT_COLLISION)) {
            return;
          }
          if (checkBagCollision(LEFT_COLLISION)) {
            return;
          }
          soko.move(-DIMENSIONS, 0);
          break;
        case KeyEvent.VK_RIGHT:
          if (checkWallCollision(soko, RIGHT_COLLISION)) {
            return;
          }
          if (checkBagCollision(RIGHT_COLLISION)) {
            return;
          }
          soko.move(DIMENSIONS, 0);
          break;
        case KeyEvent.VK_UP:
          if (checkWallCollision(soko, TOP_COLLISION)) {
            return;
          }
          if (checkBagCollision(TOP_COLLISION)) {
            return;
          }
          soko.move(0, -DIMENSIONS);
          break;
        case KeyEvent.VK_DOWN:
          if (checkWallCollision(soko, BOTTOM_COLLISION)) {
            return;
          }
          if (checkBagCollision(BOTTOM_COLLISION)) {
            return;
          }
          soko.move(0, DIMENSIONS);
          break;
        case KeyEvent.VK_R:
          restartLevel();
          break;
        default:
          break;
      }
      repaint();
    }
  }
}